# Demo Authoring & Maintenance Guide

This guide covers every step required to build, update, and embed design-system demos in `${PATH_DS_DEMOS}`. Follow it to keep interactive examples aligned with the source components in `${PATH_DS_COMPONENTS}` and the documentation pipeline served from Nuxt Content.

---

## 1. Architecture & File Layout

| Path | Purpose | Notes |
| --- | --- | --- |
| `${PATH_DS_DEMOS}/ccm-<name>-demo.vue` | Interactive Vue page demonstrating a DS component. | Uses `<script setup lang="ts">`, composition API, and DS layout utilities (`ccmSection`, `stack`, `cluster`). |
| `${PATH_DS_DEMOS}/_docs/ccm-<name>.html` | Generated HTML fragment surfaced in demo via `documentationFragment`. | Regenerated by `node ${PATH_SCRIPTS_DOCS}/generate-component-docs.ts`; never edit manually. |
| `${PATH_COMPONENT_DOCS_OUTPUT}/ccm-<name>.json` | Generated JSON powering `/docs/<component>` tabs. | Keep in sync with SFC docblocks (`${PATH_UTILS_PARSE_COMPONENT_DOCS}`). |

Naming convention: component slug matches the Vue file in `${PATH_DS_COMPONENTS}` without extension (`ccmBreadcrumb.vue` → `ccm-breadcrumb-demo.vue`). Demos currently live directly under `${PATH_DS_DEMOS}`; add subfolders only if design mandates grouping.

---

## 2. Authoring Workflow

1. **Plan scenarios**
   - Review props/slots in `${PATH_COMPONENT_DOCS_OUTPUT}` and the SFC source (`${PATH_DS_COMPONENTS}`) to list the states you must cover (variants, sizes, a11y toggles, integration cases).
   - Capture any spec linkage in `_process/spec-drafts/` if the demo introduces new UX patterns.

2. **Sketch sections**
   - Use DS layout helpers (`ccmSection`, `stack`, `cluster`, `grid`) to structure content. Maintain consistent heading hierarchy (`<h2>` per scenario).
   - Prefer interactive controls built with DS components (e.g., `ccmButton`, `ccmFormGroup`) when toggling demo state.

3. **Implement**
   - Import DS components from the global registry (auto-imported via Nuxt); explicit imports are optional but encouraged for clarity.
   - Provide a `documentationFragment` by importing `./_docs/ccm-<name>.html?raw`. Surface it near the bottom inside a `ccmSection` with `v-html` as in existing demos.
   - Keep state local using `ref`/`reactive`; avoid reliance on global stores.
   - Guard `definePageMeta` usage. When the demo must set page metadata, wrap the call:
     ```ts
     if (import.meta.client) {
       definePageMeta({ layout: 'docs2', hero: { /* ... */ } })
     }
     ```
     This keeps the demo embeddable on the `/docs/<component>` route without SSR conflicts.

4. **Document decisions**
   - When inventing new patterns (e.g., toggling JSON-LD, advanced accessibility states), cross-link guidance in `${PATH_DOCS_GUIDELINES}` so humans see the rationale.

5. **Regenerate assets**
   - Run `node ${PATH_SCRIPTS_DOCS}/generate-component-docs.ts` after updating props or docblocks. This refreshes both `_docs/*.html` fragments and `${PATH_COMPONENT_DOCS_OUTPUT}`.

---

## 3. Demo Content Requirements

Each demo must include:

- **Default Composition** – The canonical usage with minimal props, reinforcing best-practice markup/ARIA.
- **Control Panel** – Buttons, selects, or toggles using DS components to explore size, variant, color, and behavior options.
- **Content Presets** – Realistic data fed through props/slots, demonstrating how the component performs with various payloads.
- **Accessibility Section** – Keyboard navigation, ARIA labels, and any screen-reader-specific behavior.
- **Behavior & Integration** – Show external dependencies (JSON-LD toggles, router integration) and how the component plays with siblings.
- **Edge Cases** – Long labels, empty states, error conditions, or external links. Use explicit headings so the status matrix can reference coverage.
- **Documentation Embed** – Render the generated HTML fragment to reinforce parity with the usage tab.

Avoid lorem ipsum—use meaningful labels and URLs to help humans assess production readiness.

---

## 4. Embedding in Component Docs

- `${PATH_DOCS_COMPONENT_OVERVIEWS}` consumes demos directly through the `LiveDemo` component. Keep demos lightweight: export only the page implementation and avoid global layout CSS that breaks when mounted inside the docs route.
- Guard Nuxt page APIs like `definePageMeta` or `useRoute` with `import.meta.client` if they produce hydration warnings during embed.
- After updating a demo, test both `/docs/demos/ccm-<name>-demo` and `/docs/<component>` to confirm parity.

---

## 5. QA & Validation Checklist

1. `npx eslint src --ext .ts,.vue` – Ensures Vue/TypeScript lint rules stay clean.
2. `npm run lint:css` – Catch style regressions introduced by demo tweaks.
3. `npm run typecheck` – Catches type regressions in demo scripts.
4. `npm run docs:components:generate` – Refresh `_docs/*.html` and JSON payloads.
5. `npx vitest run src/tests/components` – Verify component tests still pass after demo-driven API changes.
6. Manual verification:
   - Visit `/docs/demos/ccm-<name>-demo` and exercise every control path.
   - Inspect the console for hydration or runtime warnings (common when demo logic uses client-only APIs).
   - Trigger keyboard navigation to validate focus order and ARIA expectations.
   - Load `/docs/<component>` to confirm the embedded demo renders identically.

Log any outstanding issues in `_process/docs-pipeline-evaluation.md` so follow-up work is tracked.

---

## 6. Troubleshooting & Gotchas

- **Hydration warnings** – Usually caused by unguarded `definePageMeta` or direct DOM access. Gate client-only logic with `import.meta.client` or move it into `onMounted`.
- **Stale documentationFragment** – Run the generator script; if the HTML still lacks updates, verify the component JSDoc includes the relevant `@example`/`@usage` keys parsed by `${PATH_UTILS_PARSE_COMPONENT_DOCS}`.
- **Missing demo in tabs** – Confirm `${PATH_COMPONENT_DOCS_OUTPUT}/index.json` lists the component and that the slug matches `ccm-<name>-demo`. Ensure the SFC exports a default component and doesn’t rely on route params.
- **Archived components** – Anything under `~~/_archive` is not auto-imported. When reviving an archived demo, move it into `${PATH_DS_DEMOS}` and rebuild using current patterns before linking it.
- **Performance regressions** – Keep reactive state minimal, debounce expensive computations, and avoid large fake datasets unless required to illustrate pagination/virtualization behavior.

---

Maintained demos are the visual contract for the design system. Keep them tight, realistic, and synchronized with their components so both humans and LLMs can trust the surface. When new scenarios emerge, update the demo first, regenerate docs, and then adjust narrative guides to match.